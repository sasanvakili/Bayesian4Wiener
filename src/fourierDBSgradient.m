function [sigmaPhiVecUbar, muPhiVecUbar] = fourierDBSgradient(numTheta, ...
    allVecFreq, matrixAi, matrixBbar, vecUbar, sigmaWbar, matrixAj)
% This function computes the Fourier "Dynamic basis statistics" (DBS)
% gradient as defined in Section 5 of the paper:
%   "Optimal Bayesian Affine Estimator and Active Learning for the Wiener Model".
%
% This computation is critical for implementing the proposed active learning algorithm.
%
% Paper: https://arxiv.org/abs/2504.05490
% Requirements: Bayesian4Wiener library (see README for details)
% ----------------------------------------------------------------------------------
% @author: Sasan Vakili
% @date: April 2025

sigmaPhiVecUbar = zeros(numTheta, numTheta, length(vecUbar));
if (nargout > 1)
    muPhiVecUbar = zeros(numTheta, 1, length(vecUbar));
end
for m=1:numTheta-1
    mFreq = allVecFreq(:, m);
    if (nargout > 1)
        muPhiVecUbar(m+1, :, :) = (1i*exp(1i*(mFreq')*matrixAi*matrixBbar*vecUbar)+ ...
        -1i*exp(-1i*(mFreq')*matrixAi*matrixBbar*vecUbar))*...
        exp(-(1/2)*(mFreq')*matrixAi*sigmaWbar*(matrixAi')*mFreq)*...
        (matrixBbar.')*(matrixAi.')*(mFreq);
    end
    for n=1:numTheta-1
        nFreq = allVecFreq(:, n);
        term14 = (1i*exp(1i*((mFreq')*matrixAi+(nFreq')*matrixAj)*...
            matrixBbar*vecUbar)-1i*exp(-1i*((mFreq')*matrixAi+(nFreq')*matrixAj)*...
            matrixBbar*vecUbar))*(exp(-(1/2)*((mFreq')*matrixAi+...
            (nFreq')*matrixAj)*sigmaWbar*((matrixAi')*mFreq+...
            (matrixAj')*nFreq))-exp(-(1/2)*(mFreq')*matrixAi*...
            sigmaWbar*(matrixAi')*mFreq)*exp(-(1/2)*(nFreq')*matrixAj*...
            sigmaWbar*(matrixAj')*nFreq))*(matrixBbar.')*(...
            (matrixAi.')*(mFreq)+(matrixAj.')*(nFreq));
        term23 = (1i*exp(1i*((mFreq')*matrixAi-(nFreq')*matrixAj)*...
            matrixBbar*vecUbar)-1i*exp(-1i*((mFreq')*matrixAi-(nFreq')*matrixAj)*...
            matrixBbar*vecUbar))*(exp(-(1/2)*((mFreq')*matrixAi-...
            (nFreq')*matrixAj)*sigmaWbar*((matrixAi')*mFreq-...
            (matrixAj')*nFreq))-exp(-(1/2)*(mFreq')*matrixAi*...
            sigmaWbar*(matrixAi')*mFreq)*exp(-(1/2)*(nFreq')*matrixAj...
            *sigmaWbar*(matrixAj')*nFreq))*(matrixBbar.')*(...
            (matrixAi.')*(mFreq)-(matrixAj.')*(nFreq));        
        sigmaPhiVecUbar(m+1, n+1, :) = term14+term23;
    end
end

if any(abs(imag(sigmaPhiVecUbar)) >= 1e-6)
    error(['sigmaPhi has non-negligible imaginary parts ' ...
        '(max abs(imag): %.2e)'], max(abs(imag(sigmaPhiVecUbar))));
end
sigmaPhiVecUbar = real(sigmaPhiVecUbar);

if (nargout > 1)
    if any(abs(imag(muPhiVecUbar)) >= 1e-6)
        error(['muPhi has non-negligible imaginary parts ' ...
            '(max abs(imag): %.2e)'], max(abs(imag(muPhiVecUbar))));
    end
    muPhiVecUbar = real(muPhiVecUbar);
end
end